install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
comp.cgs(toy.graph, tg.pat)
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(toy.graph, tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
comp.cgs(pattern(toy.graph), tg.pat)
#  shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
install.packages("C:/Users/hessor/Downloads/cglearn.tar.gz", repos = NULL, type = "source")
library(cglearn)
set.seed(100)
p.value <- .01
n <- 3000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
library(cglearn)
set.seed(100)
p.value <- .01
n <- 2500
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
library(cglearn)
set.seed(100)
p.value <- .5
n <- 2500
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
library(cglearn)
set.seed(100)
p.value <- .5
n <- 4000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
library(lcd)
set.seed(100)
p.value <- .5
n <- 4000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
# check comp.pat and compare the formulas for SHD
comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
lcd::comp.pat(pattern(toy.graph), tg.pat)
shd <- scores[SHD]
scores <- comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
shd <- scores[SHD]
shd <- scores['SHD']
print(shd)
scores <- comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = integer(),
degree = integer(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
curcgscores <- c('current', .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores <- rbind(rLearnedScores, curcgscores)
print(rLearnedScores)
scores <- comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = integer(),
degree = integer(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
curcgscores <- c('current', .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
newDF <- rbind(rLearnedScores, curcgscores)
print(rLearnedScores)
print(newDF)
rLearnedScores <- rbind(rLearnedScores, curcgscores)
print(rLearnedScores)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = numeric(),
degree = numeric(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
curcgscores <- c('current', .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores <- rbind(rLearnedScores, curcgscores)
print(rLearnedScores)
# check comp.pat and compare the formulas for SHD
scores <- comp.cgs(pattern(toy.graph), tg.pat)
# shd is correct here. use this code that is more reliable to compute needed metrics. This only has TP and SHD
comp.pat(pattern(toy.graph), tg.pat)
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = integer(),
degree = integer(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
curcgscores <- c('current', .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores[nrow(df) + 1,] = c('current', .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
rLearnedScores[nrow(df) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
print(scores)
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
rLearnedScores[nrow(rLearnedScores) + 1,] = c("current", .05, 200, 2, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
print(rLearnedScores)
View(rLearnedScores)
View(shd)
print(tgdata)
print(colnames(tgdata))
print(rownames(tgdata))
library(readr)
library(lcd)
writeResults <- function(adj, name){
# colnames(adj)<-rownames(adj)<-paste("v",1:50,sep = "")
write.csv(adj,file=name,row.names=FALSE)
}
#### For each CG, generate data with tgdata ####
# for all both 2 degrees and 3 degrees
for (i in 2:3) {
# for all 30 cgs with either 2 degree or 3 degree
for (j in 1:30) {
# for sample size 200 and 2000
for (z in c(200, 2000)) {
# for degree i and cg j, set the correct file path
csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, ".csv")
# Read the CSV file into a data frame
df <- read_csv(csv_file_path)
# Convert the data frame to a matrix
toy.graph <- as.matrix(df)
tgdata <- rnorm.cg(z, toy.graph, get.normal.dist(toy.graph))
# Declare name of file
name <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_data.csv")
# send info to write results
writeResults(tgdata, name)
}
}
}
View(tgdata)
setwd("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing")
library(readr)
library(cglearn)
writeResults <- function(adj){
# colnames(adj)<-rownames(adj)<-paste("v",1:50,sep = "")
write.csv(adj,file="r_learned_cg_metrics.csv",row.names=FALSE)
}
# data frame to add rows to
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = integer(),
degree = integer(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
for (i in 2:3) {
for (j in 1:30) {
for (p in c(.005, .05)) {
for (n in c(200, 2000)) {
# for degree i, set the correct file path for data
data_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_data.csv")
# for degree i, set the correct file path for cg pattern
pattern_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_pattern.csv")
# # Read the data CSV file into a data frame
# data_df <- read_csv(data_csv_file_path)
# # Read the cg pattern CSV file into a data frame
# pattern_df <- read_csv(pattern_csv_file_path)
# # Convert the data frames to a matrix
# tgdata <- as.matrix(data_df)
# cgpat <- as.matrix(pattern_df)
# # generate the undirected graph (independence graph)
# tgug <- naive.getug.norm(tgdata, p)
# # triangulate the ug and then create the junction tree
# tg.jtree <- ug.to.jtree(tgug)
# # get the pattern from the junction tree
# tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p, "CG")
# # set the name of the cg
# name <- paste0("cg50_", i,"_", j)
# # get the metrics for the preformance of the learned cg
# scores <- comp.cgs(pattern(toy.graph), tg.pat)
# # add the metrics to the scores data frame
# rLearnedScores[nrow(rLearnedScores) + 1,] = c(name, p, n, i, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
}
}
}
}
for (i in 2:3) {
for (j in 1:30) {
for (p in c(.005, .05)) {
for (n in c(200, 2000)) {
# for degree i, set the correct file path for data
data_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_data.csv")
# for degree i, set the correct file path for cg pattern
pattern_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_pattern.csv")
print(data_csv_file_path)
print(pattern_csv_file_path)
# # Read the data CSV file into a data frame
# data_df <- read_csv(data_csv_file_path)
# # Read the cg pattern CSV file into a data frame
# pattern_df <- read_csv(pattern_csv_file_path)
# # Convert the data frames to a matrix
# tgdata <- as.matrix(data_df)
# cgpat <- as.matrix(pattern_df)
# # generate the undirected graph (independence graph)
# tgug <- naive.getug.norm(tgdata, p)
# # triangulate the ug and then create the junction tree
# tg.jtree <- ug.to.jtree(tgug)
# # get the pattern from the junction tree
# tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p, "CG")
# # set the name of the cg
# name <- paste0("cg50_", i,"_", j)
# # get the metrics for the preformance of the learned cg
# scores <- comp.cgs(pattern(toy.graph), tg.pat)
# # add the metrics to the scores data frame
# rLearnedScores[nrow(rLearnedScores) + 1,] = c(name, p, n, i, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
}
}
}
}
# after each cg has been learned and the metrics are calculated, save the results into a csv
# writeResults(rLearnedScores)
for (i in 2:3) {
for (j in 1:30) {
for (p in c(.005, .05)) {
for (n in c(200, 2000)) {
# for degree i, set the correct file path for data
data_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_data.csv")
# for degree i, set the correct file path for cg pattern
pattern_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_pattern.csv")
print(data_csv_file_path)
# # Read the data CSV file into a data frame
# data_df <- read_csv(data_csv_file_path)
# # Read the cg pattern CSV file into a data frame
# pattern_df <- read_csv(pattern_csv_file_path)
# # Convert the data frames to a matrix
# tgdata <- as.matrix(data_df)
# cgpat <- as.matrix(pattern_df)
# # generate the undirected graph (independence graph)
# tgug <- naive.getug.norm(tgdata, p)
# # triangulate the ug and then create the junction tree
# tg.jtree <- ug.to.jtree(tgug)
# # get the pattern from the junction tree
# tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p, "CG")
# # set the name of the cg
# name <- paste0("cg50_", i,"_", j)
# # get the metrics for the preformance of the learned cg
# scores <- comp.cgs(pattern(toy.graph), tg.pat)
# # add the metrics to the scores data frame
# rLearnedScores[nrow(rLearnedScores) + 1,] = c(name, p, n, i, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
}
}
}
}
library(readr)
library(cglearn)
writeResults <- function(adj){
# colnames(adj)<-rownames(adj)<-paste("v",1:50,sep = "")
write.csv(adj,file="r_learned_cg_metrics.csv",row.names=FALSE)
}
# data frame to add rows to
rLearnedScores <- data.frame(
name = character(),
pval = numeric(),
samplesize = integer(),
degree = integer(),
TPR = numeric(),
TDR = numeric(),
FPR = numeric(),
ACC = numeric(),
SHD = numeric()
)
for (i in 2:3) {
for (j in 1:30) {
for (p in c(.005, .05)) {
for (n in c(200, 2000)) {
# for degree i, set the correct file path for data
data_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_data.csv")
# for degree i, set the correct file path for cg pattern
pattern_csv_file_path <- paste0("C:/Users/hessor/Documents/pcgaussiantesting/CG-Testing/cg_", i,"_50/cg50_", i,"_", j, "_pattern.csv")
# Read the data CSV file into a data frame
data_df <- read_csv(data_csv_file_path)
# Read the cg pattern CSV file into a data frame
pattern_df <- read_csv(pattern_csv_file_path)
# Convert the data frames to a matrix
tgdata <- as.matrix(data_df)
cgpat <- as.matrix(pattern_df)
# generate the undirected graph (independence graph)
tgug <- naive.getug.norm(tgdata, p)
# triangulate the ug and then create the junction tree
tg.jtree <- ug.to.jtree(tgug)
# get the pattern from the junction tree
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p, "CG")
# set the name of the cg
name <- paste0("cg50_", i,"_", j)
# get the metrics for the preformance of the learned cg
scores <- comp.cgs(pattern(toy.graph), tg.pat)
# add the metrics to the scores data frame
rLearnedScores[nrow(rLearnedScores) + 1,] = c(name, p, n, i, scores['TPR'], scores['TDR'], scores['FPR'],scores['ACC'], scores['SHD'])
}
}
}
}
debugSource("~/pcgaussiantesting/CG-Testing/pc_gaussian_learning.R")
print(i)
print(j)
print(p)
print(n)
debugSource("~/pcgaussiantesting/CG-Testing/pc_gaussian_learning.R")
debugSource("~/pcgaussiantesting/CG-Testing/pc_gaussian_learning.R")
print(toy.graph)
print(colnames(toy.graph))
debugSource("~/pcgaussiantesting/CG-Testing/pc_gaussian_learning.R")
debugSource("~/pcgaussiantesting/CG-Testing/pc_gaussian_learning.R")
dim(cgpat)
dim(tg.pat)
library(cglearn)
library(cglearn)
set.seed(100)
p.value <- .5
n <- 4000
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
scores <- comp.cgs(pattern(toy.graph), tg.pat)
is.chaingraph(toy.graph)
tgdata <- rnorm.cg(n, toy.graph, get.normal.dist(toy.graph))
tgug <- naive.getug.norm(tgdata, p.value)
tg.jtree <- ug.to.jtree(tgug)
tg.pat <- learn.mec.norm(tg.jtree, cov(tgdata), n, p.value, "CG")
comp.skel(skeleton(toy.graph), skeleton(tg.pat))
